/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct {
	uint16_t data_port_b;
	uint16_t data_port_e;
	uint16_t data_port_f;
	uint16_t data_port_g;
} sample_t;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define SAMPLE_READ_MAX					300

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

UART_HandleTypeDef huart4;
UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
UART_HandleTypeDef *esp_uart;
UART_HandleTypeDef *debug_uart;


sample_t sample[SAMPLE_READ_MAX];

sample_t *head, *curr, *tail;

int trigger = 0;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_UART4_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */
inline void get_sample();
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* Send command to GNSS module function
 * the cmd is exclude start symbol ($) and end symbol (*)
 * this function will put '$' and '*XX<CR><LF>' and send over the uart interface
 */
void gps_uart_send_cmd(char *cmd){
	char chksum = 0;
	char *pcmd = cmd;
	do{
		chksum ^= (*pcmd);
		pcmd++;
	}while(*pcmd != '\0');
	printf ("Chksum = 0x%02X\n",chksum);
}

inline void next(){

}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

	const char str[100] = "Hello from STM32\n";
  /* USER CODE END 1 */

  /* MPU Configuration--------------------------------------------------------*/
  MPU_Config();

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */
  // -- UART Mapping -- //
  esp_uart = &huart2;
  debug_uart = &huart4;
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART1_UART_Init();
  MX_UART4_Init();
  MX_USART2_UART_Init();
  /* USER CODE BEGIN 2 */
  // Set sample buffer pointer
  head = sample;
  tail = sample + SAMPLE_READ_MAX;

  // Empty all data in sample buffer
  curr = head;
  do{
	curr->data_port_b = 0;
	curr->data_port_e = 0;
	curr->data_port_f = 0;
	curr->data_port_g = 0;
  }while(++curr < tail);

  printf("Main program started\n");

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  curr = head;
  trigger = 0;
  while (1)
  {
	  if(trigger){
		  findmax2();
	  }
	/* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	//HAL_Delay(1000);
	//HAL_GPIO_TogglePin(USER_LED_GREEN_GPIO_Port, USER_LED_GREEN_Pin);
	//HAL_UART_Transmit(esp_uart, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
	//HAL_GPIO_TogglePin(USER_LED_BLUE_GPIO_Port, USER_LED_BLUE_Pin);

	// curr pointer will point to the last sample. to fill in the new sample, must move to the next slot first

	curr->data_port_b = GPIOB->IDR;
	curr->data_port_e = GPIOE->IDR;
	curr->data_port_f = GPIOF->IDR;
	curr->data_port_g = GPIOG->IDR;

	if(curr == tail){
	  curr = head;
	}else{
	  curr++;
	}

  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 216;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief UART4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UART4_Init(void)
{

  /* USER CODE BEGIN UART4_Init 0 */

  /* USER CODE END UART4_Init 0 */

  /* USER CODE BEGIN UART4_Init 1 */

  /* USER CODE END UART4_Init 1 */
  huart4.Instance = UART4;
  huart4.Init.BaudRate = 115200;
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN UART4_Init 2 */

  /* USER CODE END UART4_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, USER_LED_GREEN_Pin|USER_LED_BLUE_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : GPIO_USER_SW_Pin */
  GPIO_InitStruct.Pin = GPIO_USER_SW_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIO_USER_SW_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : D0A_Pin D1A_Pin D2A_Pin D3A_Pin
                           D4A_Pin D5A_Pin D6A_Pin D7A_Pin
                           D8A_Pin D9A_Pin CT2_Pin CT3_Pin
                           CT4_Pin CT5_Pin CT6_Pin */
  GPIO_InitStruct.Pin = D0A_Pin|D1A_Pin|D2A_Pin|D3A_Pin
                          |D4A_Pin|D5A_Pin|D6A_Pin|D7A_Pin
                          |D8A_Pin|D9A_Pin|CT2_Pin|CT3_Pin
                          |CT4_Pin|CT5_Pin|CT6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : CT0_Pin CT1_Pin CT18_Pin CT19_Pin */
  GPIO_InitStruct.Pin = CT0_Pin|CT1_Pin|CT18_Pin|CT19_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : CT7_Pin CT8_Pin CT23_Pin CT22_Pin
                           CT21_Pin CT20_Pin D0B_Pin D1B_Pin
                           D2B_Pin D3B_Pin D4B_Pin D5B_Pin
                           D6B_Pin D7B_Pin D8B_Pin D9B_Pin */
  GPIO_InitStruct.Pin = CT7_Pin|CT8_Pin|CT23_Pin|CT22_Pin
                          |CT21_Pin|CT20_Pin|D0B_Pin|D1B_Pin
                          |D2B_Pin|D3B_Pin|D4B_Pin|D5B_Pin
                          |D6B_Pin|D7B_Pin|D8B_Pin|D9B_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /*Configure GPIO pins : CT9_Pin CT10_Pin CT11_Pin CT12_Pin
                           CT13_Pin CT14_Pin CT15_Pin CT16_Pin
                           CT17_Pin */
  GPIO_InitStruct.Pin = CT9_Pin|CT10_Pin|CT11_Pin|CT12_Pin
                          |CT13_Pin|CT14_Pin|CT15_Pin|CT16_Pin
                          |CT17_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : USER_LED_GREEN_Pin USER_LED_BLUE_Pin */
  GPIO_InitStruct.Pin = USER_LED_GREEN_Pin|USER_LED_BLUE_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : PD8 PD9 */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*Configure GPIO pins : GPIO_TRIG_P_Pin GPIO_TRIG_N_Pin */
  GPIO_InitStruct.Pin = GPIO_TRIG_P_Pin|GPIO_TRIG_N_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);

  HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI3_IRQn);

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
#define TB_MODE							TB_MODE_0
#define MAX_BUF_SIZE					100



typedef struct {
	int16_t ns_adc;
	int16_t ew_adc;
	uint32_t ns_t;
	uint32_t ew_t;
	uint32_t counter;
} data_record_t;

typedef struct {
	int16_t max_adc_ns;
	int16_t max_adc_ew;
	uint32_t time_max_ns;
	uint32_t time_max_ew;
} max_sample_t;

data_record_t data[SAMPLE_READ_MAX];
max_sample_t max_sample;



int16_t convert_number(uint16_t data){
	int16_t value;
#if TB_MODE == TB_MODE_0
		if((data & 0x0200) > 0){
			// Positive
			value = data & 0x01ff;
		}else{
			// Negative
			value = -(((~data + 1) & 0x01ff));
		}
#else
		if((data & 0x0200) > 0){
			// Negative
			value = -(~data + 0x0001);
		} else{
			// Positive
			value = data & 0x01ff;
		}
#endif
	return value;
}


void read_adc2(){

}


void read_adc(){
	// Read 300 samples
	int count;
	uint16_t adc_data_a, adc_data_b;
	int16_t adc_value_a, adc_value_b;
	uint32_t counter;
	sample_t *p_sample;


	// temp
	uint32_t counter_first, counter_last;

	// On LED to indicate adc read
	//HAL_GPIO_WritePin(USER_LED_BLUE_GPIO_Port, USER_LED_BLUE_Pin, 1);
	count = 0;
	p_sample = sample;
	do{
		p_sample->data_port_b = GPIOB->IDR;
		p_sample->data_port_e = GPIOE->IDR;
		p_sample->data_port_f = GPIOF->IDR;
		p_sample->data_port_g = GPIOG->IDR;
		p_sample++;
	}while(++count < SAMPLE_READ_MAX);

	// Off LED to indicate read complete
	HAL_GPIO_WritePin(USER_LED_BLUE_GPIO_Port, USER_LED_BLUE_Pin, 0);


	// Post Processing
	count = 0;
	p_sample = sample;
	do{
		uint16_t temp1, temp2;

		adc_data_a = p_sample->data_port_f & 0x03ff;
		//data[count].ns_adc = p_sample->data_port_f & 0x03ff;
		adc_data_b = (p_sample->data_port_g >> 6) & 0x03ff;
		//data[count].ew_adc = p_sample->data_port_f & 0x03ff;



		counter = 0;
		// CT23-CT20 (4 bits)
		temp1 = p_sample->data_port_g; 	// CT23-PG2, CT22-PG3, CT21-PG4, CT20-PG5
		//temp2 = ((temp1 & 0x0004) << 1) | ((temp1 & 0x0008) >> 1) | ((temp1 & 0x0010) >> 3) | ((temp1 & 0x0020) >> 5);
		//counter = temp2 << 20;
		counter |= (temp1 & 0x0004) << 21;
		counter |= (temp1 & 0x0008) << 19;
		counter |= (temp1 & 0x0010) << 17;
		counter |= (temp1 & 0x0020) << 15;


		// CT19-CT18 (2 bits)
		temp1 = p_sample->data_port_b;	// CT19-PB11, CT18-PB10
		temp2 = (temp1 >> 10) & 0x0003;
		counter |= (temp2 << 18);

		// CT17-CT9 (9 bits)
		temp1 = p_sample->data_port_e;	// CT17-PE15 ... CT9-PB7
		temp2 = (temp1 >> 7) & 0x01ff;
		counter |= (temp2 << 9);

		// CT8-CT7 (2 bits)
		temp1 = p_sample->data_port_g;	// CT8-PG1, CT7-PG0
		temp2 = temp1 & 0x0003;
		counter |= (temp2 << 7);

		// CT6-CT2 (5 bits)
		temp1 = p_sample->data_port_f;	// CT6-PF15 ... CT2-PF11
		temp2 = (temp1 >> 11) & 0x001f;
		counter |= (temp2 << 2);

		// CT1-CT0 (2 bits)
		temp1 = p_sample->data_port_b;	// CT1-PB2, CT0-PB1
		temp2 = (temp1 >> 1) & 0x0003;
		counter |= temp2;

		adc_value_a = convert_number(adc_data_a);
		adc_value_b = convert_number(adc_data_b);


		if (count == 0) counter_first = counter;
		if (count == SAMPLE_READ_MAX - 1) counter_last = counter;

		data[count].ns_adc = adc_value_a;
		data[count].ew_adc = adc_value_b;
		data[count].counter = counter;

		//printf ("Sample %d\tPort A = 0x%04X (%d) %.4f V,\tPort B = 0x%04X (%d)\t Time = 0x%06X\n",count+1, adc_data_a, adc_value_a, ((adc_value_a / 512.0) + 1.5), adc_data_b, adc_value_b, counter);


		p_sample++;
	}while(++count < SAMPLE_READ_MAX);
	printf ("Sample read period = %d cycles\n", counter_last - counter_first);
}

void find_max(){
	int count;
	int16_t max_ns_adc, max_b_adc;
	uint32_t max_ns_t, max_b_t;






	max_sample.max_adc_ns = 423;
	max_sample.max_adc_ew = -217;
	//max_sample.time_max_ns = 615228;
	//max_sample.time_max_ew = 7108862;
	//max_sample.time_max_ns = 615228;
	//max_sample.time_max_ew = 7108862;
	count = 0;

	max_ns_adc = data[0].ns_adc;
	do{
		if (data[count].ns_adc > max_ns_adc){
			max_ns_adc = data[count].ns_adc;
			max_ns_t = data[count].counter;
		}
	}while(++count < SAMPLE_READ_MAX);

	printf("Max NS ADC = %d Voltage %2.4f at counter %lu, time after trig = %d.%d us\n", max_ns_adc, (max_ns_adc / 512.0) + 1.5, max_ns_t, (max_ns_t - data[0].counter) / 10, (max_ns_t - data[0].counter) % 10 );
}

void send_data(){
	char send_buf[MAX_BUF_SIZE];
	uint8_t chksum = 0xa5;
	sprintf(send_buf, "$STMFIELD,%d,%lu,%d,%lu*%02X\r\n", max_sample.max_adc_ns,max_sample.time_max_ns, max_sample.max_adc_ew, max_sample.time_max_ew, chksum);
	printf("%s",send_buf);
	HAL_UART_Transmit(esp_uart, (uint8_t*)send_buf, strlen(send_buf), HAL_MAX_DELAY);
}


void find_max2(){
	int16_t max_ns_v;
	uint32_t max_ns_t;

	int count;
	uint16_t adc_data_a, adc_data_b;
	int16_t adc_value_a, adc_value_b;
	uint32_t counter;
	sample_t *p_sample;


	// temp
	uint32_t counter_first, counter_last;

	// On LED to indicate adc read
	//HAL_GPIO_WritePin(USER_LED_BLUE_GPIO_Port, USER_LED_BLUE_Pin, 1);





	count = 0;
	curr = head;
	max_ns_v = 0;

	do{
		uint16_t temp1, temp2;

		adc_data_a = curr->data_port_f & 0x03ff;
	//data[count].ns_adc = p_sample->data_port_f & 0x03ff;
		adc_data_b = (curr->data_port_g >> 6) & 0x03ff;
	//data[count].ew_adc = p_sample->data_port_f & 0x03ff;



	counter = 0;
	// CT23-CT20 (4 bits)
	temp1 = curr->data_port_g; 	// CT23-PG2, CT22-PG3, CT21-PG4, CT20-PG5
	//temp2 = ((temp1 & 0x0004) << 1) | ((temp1 & 0x0008) >> 1) | ((temp1 & 0x0010) >> 3) | ((temp1 & 0x0020) >> 5);
	//counter = temp2 << 20;
	counter |= (temp1 & 0x0004) << 21;
	counter |= (temp1 & 0x0008) << 19;
	counter |= (temp1 & 0x0010) << 17;
	counter |= (temp1 & 0x0020) << 15;


	// CT19-CT18 (2 bits)
	temp1 = curr->data_port_b;	// CT19-PB11, CT18-PB10
	temp2 = (temp1 >> 10) & 0x0003;
	counter |= (temp2 << 18);

	// CT17-CT9 (9 bits)
	temp1 = curr->data_port_e;	// CT17-PE15 ... CT9-PB7
	temp2 = (temp1 >> 7) & 0x01ff;
	counter |= (temp2 << 9);

	// CT8-CT7 (2 bits)
	temp1 = curr->data_port_g;	// CT8-PG1, CT7-PG0
	temp2 = temp1 & 0x0003;
	counter |= (temp2 << 7);

	// CT6-CT2 (5 bits)
	temp1 = curr->data_port_f;	// CT6-PF15 ... CT2-PF11
	temp2 = (temp1 >> 11) & 0x001f;
	counter |= (temp2 << 2);

	// CT1-CT0 (2 bits)
	temp1 = curr->data_port_b;	// CT1-PB2, CT0-PB1
	temp2 = (temp1 >> 1) & 0x0003;
	counter |= temp2;

	adc_value_a = convert_number(adc_data_a);
	adc_value_b = convert_number(adc_data_b);


	if (count == 0) counter_first = counter;
	if (count == SAMPLE_READ_MAX - 1) counter_last = counter;

	//data[count].ns_adc = adc_value_a;
	//data[count].ew_adc = adc_value_b;
	//data[count].counter = counter;
	count++;
		if (((adc_value_a / 512.0) + 1.50) > max_ns_v) {
			max_ns_v = ((adc_value_a / 512.0) + 1.50);
			max_ns_t = counter;
		}

	} while(++curr < tail);

	//printf("find max fn : Max NS = %2.4f @ timer counter %lu, %d.%d\n", max_ns_v, max_ns_t, (max_ns_t -counter_first) / 10,(max_ns_t -counter_first) % 10);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin == GPIO_TRIG_P_Pin) {
		printf("Trigger + detected\n");
		read_adc();
		find_max();
	} else if (GPIO_Pin == GPIO_TRIG_N_Pin) {
		printf("Trigger - detected\n");
		read_adc();
	} else if(GPIO_Pin == GPIO_USER_SW_Pin){
		//printf("User switch pressed\n");
		//read_adc();
		find_max2();
		//send_data();
	} else {
      __NOP();
  }
}


// Overwite the _write function that defined in syscall.c
int _write(int file, char *ptr, int len)
{
    //HAL_UART_Transmit(&huart4, (uint8_t *)ptr, len, HAL_MAX_DELAY);
    HAL_UART_Transmit(debug_uart, (uint8_t *)ptr, len, HAL_MAX_DELAY);
    return len;
}

/* USER CODE END 4 */

 /* MPU Configuration */

void MPU_Config(void)
{
  MPU_Region_InitTypeDef MPU_InitStruct = {0};

  /* Disables the MPU */
  HAL_MPU_Disable();

  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress = 0x0;
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);

}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
